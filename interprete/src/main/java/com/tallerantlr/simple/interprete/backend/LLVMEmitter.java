package com.tallerantlr.simple.interprete.backend;

import com.tallerantlr.simple.interprete.ir.IR.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Emite LLVM IR textual desde el IR (TAC) propio.
 * Tipado:
 *  - i32 para ints
 *  - i1  para bools (icmp/and/or/not)
 *  - i8* para strings (solo constantes)
 * Modelo:
 *  - Globales: @g : i32
 *  - Locales:  %g.alloca : i32* + loads/stores
 *  - Temps:    SSA (%t1, %t2, ...)
 */
public class LLVMEmitter {

    enum VType { INT, BOOL, STR }

    private final StringBuilder sb = new StringBuilder();
    private final StringBuilder strDefs = new StringBuilder(); // << NUEVO: acumulador de strings
    private final IRModule mod;
    private final Map<String,String> strGlobals = new LinkedHashMap<>();
    private int strCounter = 0;

    // Tipos estimados por temporales
    private final Map<String,VType> tempType = new HashMap<>();

    public LLVMEmitter(IRModule mod) { this.mod = mod; }

    public String emit() {
        header();   
        declareRuntime();
        emitGlobals();
        for (IRFunction f : mod.functions.values()) emitFunction(f);
        sb.append(strDefs); 
        return sb.toString();
    }

    private void header() {
        sb.append("; generated by LLVMEmitter\n");
        sb.append("source_filename = \"program\"\n");              // << NUEVO
        sb.append("target triple = \"").append(defaultTriple()).append("\"\n\n");
    }
    private String defaultTriple() {
        String os = System.getProperty("os.name","").toLowerCase();
        if (os.contains("win")) return "x86_64-pc-windows-msvc";
        if (os.contains("mac")) return "x86_64-apple-darwin";
        return "x86_64-pc-linux-gnu";
    }

    private void declareRuntime() {
        sb.append("declare void @println_i32(i32)\n");
        sb.append("declare void @println_bool(i1)\n");
        sb.append("declare void @println_cstr(ptr)\n");

        sb.append("declare void @turtle_avanza(i32)\n");
        sb.append("declare void @turtle_giraDerecha(i32)\n");
        sb.append("declare void @turtle_giraIzquierda(i32)\n");
        sb.append("declare void @turtle_centro()\n");
        sb.append("declare void @turtle_ponX(i32)\n");
        sb.append("declare void @turtle_ponY(i32)\n");
        sb.append("declare void @turtle_ponPos(i32,i32)\n");
        sb.append("declare void @turtle_bajaLapiz()\n");
        sb.append("declare void @turtle_subeLapiz()\n");
        sb.append("declare void @turtle_ponColorLapiz(i32)\n");
        sb.append("declare void @turtle_espera(i32)\n");
        sb.append("declare void @turtle_oculta()\n");
        sb.append("declare void @turtle_rumbo()\n");
        sb.append("declare void @turtle_ponRumbo(i32)\n");
        sb.append("declare void @turtle_retrocede(i32)\n");
        sb.append("declare i32 @runtime_azar(i32)\n\n");
    }


    private void emitGlobals() {
        for (String g : mod.globals) {
            sb.append("@").append(g).append(" = global i32 0\n");
        }
        if (!mod.globals.isEmpty()) sb.append("\n");
    }

    // ==== utilities for strings ====
    private String internString(String s) {
        String existing = strGlobals.get(s);
        if (existing != null) return existing; // devuelve ".strN"

        String name = ".str" + (strCounter++);
        String escaped = s
                .replace("\\", "\\5C")
                .replace("\n", "\\0A")
                .replace("\r", "\\0D")
                .replace("\"", "\\22");
        int n = s.length() + 1;

        // Definición SIEMPRE como @.strN ...
        String def = "@" + name + " = private constant [" + n + " x i8] c\"" + escaped + "\\00\"\n";
        strDefs.append(def);                 // << NUEVO: se acumula aquí (no insert 0)

        strGlobals.put(s, name);             // guarda ".strN"
        return name;                         // devuelve ".strN" (sin @)
    }

    private String cstrPtr(String global) {
        // getelementptr para i8*
        // %p = getelementptr inbounds ([N x i8], [N x i8]* @.str, i32 0, i32 0)
        // Lo generaremos inline donde se use.
        return global;
    }

    // ==== function emission ====
    private void emitFunction(IRFunction f) {
        // firma: todo void; params i32
        String params = f.params.stream()
                .map(p -> "i32 %"+p)
                .collect(Collectors.joining(", "));
        sb.append("define void @").append(f.name).append("(").append(params).append(") {\n");

        // entry: allocas
        sb.append("entry:\n");

        // locals: allocas
        Set<String> locals = new LinkedHashSet<>(f.locals);
        locals.addAll(f.params); // reservamos espacio para params como variables
        for (String v : locals) {
            sb.append("  %").append(v).append(".alloca = alloca i32\n");
        }
        // store de params
        for (String p : f.params) {
        	sb.append("  store i32 %").append(p).append(", ptr %").append(p).append(".alloca\n");        
        	}

        boolean afterTerm = false;     // true si el bloque anterior terminó (br/ret)
        int contCount = 0;

        for (IRInstr ins : f.code) {

            // 1) Si viene un LABEL y no se terminó el bloque anterior, cierra con br
            if (ins instanceof IRLabelInstr) {
                IRLabelInstr L = (IRLabelInstr) ins;
                if (!afterTerm) {
                    sb.append("  br label %").append(L.label.name).append("\n");
                }
                sb.append(L.label.name).append(":\n");
                afterTerm = false;
                continue;
            }

            // 2) Si el bloque anterior terminó y lo que sigue no es LABEL, abre un bloque nuevo
            if (afterTerm) {
                String c = "_cont" + (++contCount);
                sb.append(c).append(":\n");
                afterTerm = false;
            }

            // 3) Terminadores
            if (ins instanceof IRGoto) {
                IRGoto g = (IRGoto) ins;
                sb.append("  br label %").append(g.target.name).append("\n");
                afterTerm = true;
                continue;
            }

            if (ins instanceof IRIfGoto) {
                IRIfGoto ig = (IRIfGoto) ins;
                String c = asValue(ig.cond, VType.BOOL);
                String cfall = "_cont" + (++contCount);
                sb.append("  br i1 ").append(c)
                  .append(", label %").append(ig.target.name)
                  .append(", label %").append(cfall).append("\n");
                sb.append(cfall).append(":\n");   // empezamos el bloque de caída
                afterTerm = false;
                continue;
            }

            if (ins instanceof IRReturn) {
                sb.append("  ret void\n");
                afterTerm = true;
                continue;
            }
            if (ins instanceof IRPrintln) {
                IRPrintln p = (IRPrintln) ins;
                // cadenas literales → println_cstr
                if (p.value instanceof IRConst && ((IRConst)p.value).value instanceof String) {
                	String txt = (String)((IRConst)p.value).value;
                	String sym = internString(txt);  // ".strN"
                	int n = txt.length() + 1;
                	String tmp = fresh();
                	sb.append("  ").append(tmp)
                	  .append(" = getelementptr inbounds [")
                	  .append(n).append(" x i8], ptr @")
                	  .append(sym).append(", i32 0, i32 0\n");
                	sb.append("  call void @println_cstr(ptr ").append(tmp).append(")\n");
                } else {
                    // si sabemos que es bool → println_bool; si no, i32
                    VType vt = guessType(p.value);
                    String v = asValue(p.value, vt);
                    if (vt == VType.BOOL) {
                        sb.append("  call void @println_bool(i1 ").append(v).append(")\n");
                    } else {
                        if (vt == VType.BOOL) {
                            // (ya está cubierto)
                        }
                        // si era bool y lo pedimos como i32 hacemos zext en asValue
                        sb.append("  call void @println_i32(i32 ").append(v).append(")\n");
                    }
                }
                continue;
            }
            
            if (ins instanceof IRMove) {
                IRMove m = (IRMove) ins;

                // ===== Asignación a variable (global o local) =====
                if (m.dst instanceof IRVar) {
                    String ptr = ptrOf((IRVar)m.dst);

                    // Miramos el tipo del RHS
                    VType srcType = guessType(m.src);
                    String v;

                    if (srcType == VType.STR) {
                        // src es una cadena → asValue genera un ptr (resultado de getelementptr)
                        String p = asValue(m.src, VType.STR);   // p : ptr
                        String tmpInt = fresh();                // tmpInt : i32

                        // Convertimos el ptr a i32 para poder almacenarlo en la global i32
                        sb.append("  ").append(tmpInt)
                          .append(" = ptrtoint ptr ").append(p).append(" to i32\n");

                        v = tmpInt;
                    } else {
                        // int/bool normales → como antes
                        v = asValue(m.src, VType.INT);
                    }

                    sb.append("  store i32 ").append(v).append(", ptr ").append(ptr).append("\n");
                }

                // ===== Asignación a temporal SSA =====
                else if (m.dst instanceof IRTemp) {
                    String dst = "%"+((IRTemp)m.dst).name;
                    VType vt = guessType(m.src);
                    String v  = asValue(m.src, vt);

                    if (vt == VType.BOOL) {
                        tempType.put(((IRTemp)m.dst).name, VType.BOOL);
                        sb.append("  ").append(dst).append(" = or i1 ").append(v).append(", false\n");
                    } else {
                        tempType.put(((IRTemp)m.dst).name, VType.INT);
                        if (v.equals("true") || v.equals("false")) {
                            String b = fresh();
                            sb.append("  ").append(b).append(" = zext i1 ").append(v).append(" to i32\n");
                            sb.append("  ").append(dst).append(" = add i32 ").append(b).append(", 0\n");
                        } else {
                            sb.append("  ").append(dst).append(" = add i32 ").append(v).append(", 0\n");
                        }
                    }
                }

                continue;
            }


            if (ins instanceof IRBinOpInstr) {
                IRBinOpInstr b = (IRBinOpInstr) ins;
                String dst = "%"+((IRTemp)b.dst).name;
                switch (b.op) {
                    case ADD: emitArith(dst, "add", b.a, b.b); break;
                    case MUL: emitArith(dst, "mul", b.a, b.b); break;
                    case DIV: emitArith(dst, "sdiv", b.a, b.b); break;
                    case SUB: emitArith(dst, "sub", b.a, b.b); break;
                    case EQ:  emitCmp(dst, "eq", b.a, b.b);  break;
                    case LT:  emitCmp(dst, "slt", b.a, b.b); break;
                    case GT:  emitCmp(dst, "sgt", b.a, b.b); break;
                    case AND: emitBoolBin(dst, "and", b.a, b.b); break;
                    case OR:  emitBoolBin(dst, "or",  b.a, b.b); break;
                    case POW: emitPow(dst, b.a, b.b); break;
                    case DIFF: emitArith(dst, "sub", b.a, b.b); break;
                    case SUM:  emitArith(dst, "add", b.a, b.b); break;
                    case PROD: emitArith(dst, "mul", b.a, b.b); break;
                    default:
                        sb.append("  ; unsupported binop ").append(b.op).append("\n");
                }
                continue;
            }
            if (ins instanceof IRUnaryOpInstr) {
                IRUnaryOpInstr u = (IRUnaryOpInstr) ins;
                String dst = "%"+((IRTemp)u.dst).name;
                switch (u.op) {
                    case NOT: {
                        String v = asValue(u.v, VType.BOOL);
                        tempType.put(((IRTemp)u.dst).name, VType.BOOL);
                        sb.append("  ").append(dst).append(" = xor i1 ").append(v).append(", true\n");
                        break;
                    }
                    case NEG: {
                        String v = asValue(u.v, VType.INT);
                        tempType.put(((IRTemp)u.dst).name, VType.INT);
                        sb.append("  ").append(dst).append(" = sub i32 0, ").append(v).append("\n");
                        break;
                    }
                    default:
                        sb.append("  ; unsupported unary ").append(u.op).append("\n");
                }
                continue;
            }
            if (ins instanceof IRCall) {
                IRCall c = (IRCall) ins;
                String callee = mapCallee(c.callee);

                List<String> args = new ArrayList<>();
                List<String> argTys = new ArrayList<>();

                for (IRValue av : c.args) {
                    if (av instanceof IRConst && ((IRConst)av).value instanceof String) {
                        String txt = (String)((IRConst)av).value;
                        String sym = internString(txt);   // ".strN"
                        int n = txt.length() + 1;
                        String tmp = fresh();
                        sb.append("  ").append(tmp)
                          .append(" = getelementptr inbounds [")
                          .append(n).append(" x i8], ptr @")
                          .append(sym).append(", i32 0, i32 0\n");
                        args.add(tmp);
                        argTys.add("ptr"); // <-- antes "i8*"
                    } else {
                        String v = asValue(av, VType.INT);
                        args.add(v);
                        argTys.add("i32");
                    }
                }

                if (c.dst == null) {
                    sb.append("  call ").append(retTy(c.callee)).append(" @").append(callee)
                      .append("(").append(joinSig(argTys, args)).append(")\n");
                } else {
                    String dst = "%"+((IRTemp)c.dst).name;
                    if (c.callee.startsWith("runtime.azar")) {
                        tempType.put(((IRTemp)c.dst).name, VType.INT);
                        sb.append("  ").append(dst).append(" = call i32 @runtime_azar(")
                          .append(joinSig(argTys, args)).append(")\n");
                    } else {
                        sb.append("  call ").append(retTy(c.callee)).append(" @").append(callee)
                          .append("(").append(joinSig(argTys, args)).append(")\n");
                        tempType.put(((IRTemp)c.dst).name, VType.INT);
                        sb.append("  ").append(dst).append(" = add i32 0, 0\n");
                    }
                }
                continue;
            }

            // fallback
            sb.append("  ; unhandled: ").append(ins.getClass().getSimpleName()).append("\n");
        }

        sb.append("}\n\n");
    }

    private String retTy(String callee) {
        if (callee.startsWith("runtime.azar")) return "i32";
        if (callee.startsWith("turtle.")) return "void";
        return "void"; // user procs sin retorno
    }

    private String mapCallee(String c) {
        if (c.startsWith("turtle.")) {
            return c.replace('.', '_');
        }
        if (c.startsWith("runtime.")) {
            return c.replace('.', '_');
        }
        return c; // user function
    }

    private String joinSig(List<String> tys, List<String> vs) {
        List<String> parts = new ArrayList<>();
        for (int i=0;i<tys.size();i++) parts.add(tys.get(i) + " " + vs.get(i));
        return String.join(", ", parts);
    }

    private void emitArith(String dst, String op, IRValue a, IRValue b) {
        String va = asValue(a, VType.INT);
        String vb = asValue(b, VType.INT);
        tempType.put(dst.substring(1), VType.INT);
        sb.append("  ").append(dst).append(" = ").append(op).append(" i32 ").append(va).append(", ").append(vb).append("\n");
    }

    private void emitCmp(String dst, String pred, IRValue a, IRValue b) {
        String va = asValue(a, VType.INT);
        String vb = asValue(b, VType.INT);
        tempType.put(dst.substring(1), VType.BOOL);
        sb.append("  ").append(dst).append(" = icmp ").append(pred).append(" i32 ").append(va).append(", ").append(vb).append("\n");
    }

    private void emitBoolBin(String dst, String op, IRValue a, IRValue b) {
        String va = asValue(a, VType.BOOL);
        String vb = asValue(b, VType.BOOL);
        tempType.put(dst.substring(1), VType.BOOL);
        sb.append("  ").append(dst).append(" = ").append(op).append(" i1 ").append(va).append(", ").append(vb).append("\n");
    }

    private void emitPow(String dst, IRValue a, IRValue b) {
        // a^b con exponente entero no negativo
        String base = asValue(a, VType.INT);
        String exp  = asValue(b, VType.INT);
        tempType.put(dst.substring(1), VType.INT);

        // variables "locales" para el bucle (acumulador y contador)
        String resPtr = fresh();  // ptr i32
        String iPtr   = fresh();  // ptr i32
        sb.append("  ").append(resPtr).append(" = alloca i32\n");
        sb.append("  store i32 1, ptr ").append(resPtr).append("\n");   // res = 1
        sb.append("  ").append(iPtr).append(" = alloca i32\n");
        sb.append("  store i32 0, ptr ").append(iPtr).append("\n");     // i = 0

        // etiquetas
        String Lc = freshLabel("pow_c"); // condición
        String Lb = freshLabel("pow_b"); // cuerpo
        String Le = freshLabel("pow_e"); // salida

        // cerrar el bloque actual y saltar al de condición
        sb.append("  br label ").append(Lc).append("\n");

        // --- bloque condición ---
        sb.append(Lc.substring(1)).append(":\n");
        String iVal = fresh();
        sb.append("  ").append(iVal).append(" = load i32, ptr ").append(iPtr).append("\n");
        String cmp = fresh();
        sb.append("  ").append(cmp).append(" = icmp slt i32 ").append(iVal).append(", ").append(exp).append("\n");
        sb.append("  br i1 ").append(cmp).append(", label ").append(Lb).append(", label ").append(Le).append("\n");

        // --- bloque cuerpo ---
        sb.append(Lb.substring(1)).append(":\n");
        String resVal = fresh();
        sb.append("  ").append(resVal).append(" = load i32, ptr ").append(resPtr).append("\n");
        String mul = fresh();
        sb.append("  ").append(mul).append(" = mul i32 ").append(resVal).append(", ").append(base).append("\n");
        sb.append("  store i32 ").append(mul).append(", ptr ").append(resPtr).append("\n");
        String iInc = fresh();
        sb.append("  ").append(iInc).append(" = add i32 ").append(iVal).append(", 1\n");
        sb.append("  store i32 ").append(iInc).append(", ptr ").append(iPtr).append("\n");
        sb.append("  br label ").append(Lc).append("\n");

        // --- bloque salida ---
        sb.append(Le.substring(1)).append(":\n");
        String out = fresh();
        sb.append("  ").append(out).append(" = load i32, ptr ").append(resPtr).append("\n");
        sb.append("  ").append(dst).append(" = add i32 ").append(out).append(", 0\n");
    }


    private String ptrOf(IRVar v) {
        String name = v.name;
        if (isGlobal(name)) return "@"+name;
        return "%"+name+".alloca";
    }

    private boolean isGlobal(String name) { return mod.globals.contains(name); }

    private VType guessType(IRValue v) {
        if (v instanceof IRConst) {
            Object o = ((IRConst)v).value;
            if (o instanceof String) return VType.STR;
            if (o instanceof Boolean) return VType.BOOL;
            return VType.INT;
        }
        if (v instanceof IRTemp) {
            VType t = tempType.get(((IRTemp)v).name);
            return (t == null) ? VType.INT : t;
        }
        // VarRef (IRVar) -> int (el runtime maneja ints/bools como i32; los bools se forman con icmp/and/or)
        return VType.INT;
    }

    private String asValue(IRValue v, VType want) {
    	if (v instanceof IRConst) {
    	    Object o = ((IRConst)v).value;

    	    // === Cadenas ===
    	    if (o instanceof String) {
    	        String s = (String) o;
    	        String sym = internString(s);   // ".strN"
    	        int n = s.length() + 1;
    	        String tmp = fresh();
    	        sb.append("  ").append(tmp)
    	          .append(" = getelementptr inbounds [")
    	          .append(n).append(" x i8], ptr @")
    	          .append(sym).append(", i32 0, i32 0\n");
    	        return tmp; // ptr
    	    }

    	    // === Booleanos ===
    	    if (o instanceof Boolean) {
    	        boolean b = (Boolean) o;
    	        if (want == VType.BOOL) {
    	            // Cuando realmente queremos un i1 (icmp, and, or, println_bool, etc.)
    	            return b ? "true" : "false";
    	        } else {
    	            // Cuando queremos un i32 (stores a globals, aritmética, etc.)
    	            return b ? "1" : "0";
    	        }
    	    }

    	    // === Números ===
    	    return String.valueOf(((Number)o).intValue());
    	}

        if (v instanceof IRTemp) {
            String n = "%"+((IRTemp)v).name;
            VType have = guessType(v);
            if (want == VType.INT && have == VType.BOOL) {
                String z = fresh();
                sb.append("  ").append(z).append(" = zext i1 ").append(n).append(" to i32\n");
                return z;
            }
            if (want == VType.BOOL && have == VType.INT) {
                String cmp = fresh();
                sb.append("  ").append(cmp).append(" = icmp ne i32 ").append(n).append(", 0\n");
                tempType.put(((IRTemp)v).name, VType.BOOL);
                return cmp;
            }
            return n;
        }
        if (v instanceof IRVar) {
            String p = ptrOf((IRVar)v);
            String tmp = fresh();
            sb.append("  ").append(tmp).append(" = load i32, ptr ").append(p).append("\n");
            if (want == VType.BOOL) {
                String cmp = fresh();
                sb.append("  ").append(cmp).append(" = icmp ne i32 ").append(tmp).append(", 0\n");
                return cmp;
            }
            return tmp;
        }
        return "0";
    }

    private int id = 0, lid = 0;
    private String fresh() { return "%_t" + (++id); }
    private String freshLabel(String b){ return "%"+b+"_"+(++lid); }
}
