package com.tallerantlr.simple.interprete.backend;

import com.tallerantlr.simple.interprete.ir.IR.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Emite LLVM IR textual desde el IR (TAC) propio.
 * Tipado:
 *  - i32 para ints
 *  - i1  para bools (icmp/and/or/not)
 *  - i8* para strings (solo constantes)
 * Modelo:
 *  - Globales: @g : i32
 *  - Locales:  %g.alloca : i32* + loads/stores
 *  - Temps:    SSA (%t1, %t2, ...)
 */
public class LLVMEmitter {

    enum VType { INT, BOOL, STR }

    private final StringBuilder sb = new StringBuilder();
    private final IRModule mod;
    private final Map<String,String> strGlobals = new LinkedHashMap<>(); // texto -> @.strN
    private int strCounter = 0;

    // Tipos estimados por temporales
    private final Map<String,VType> tempType = new HashMap<>();

    public LLVMEmitter(IRModule mod) { this.mod = mod; }

    public String emit() {
        header();
        declareRuntime();
        emitGlobals();
        for (IRFunction f : mod.functions.values()) emitFunction(f);
        return sb.toString();
    }

    private void header() {
        sb.append("; generated by LlvmEmitter\n");
        sb.append("target triple = \"").append(defaultTriple()).append("\"\n\n");
    }
    private String defaultTriple() {
        String os = System.getProperty("os.name","").toLowerCase();
        if (os.contains("win")) return "x86_64-pc-windows-msvc";
        if (os.contains("mac")) return "x86_64-apple-darwin";
        return "x86_64-pc-linux-gnu";
    }

    private void declareRuntime() {
        sb.append("declare void @println_i32(i32)\n");
        sb.append("declare void @println_bool(i1)\n");
        sb.append("declare void @println_cstr(i8*)\n");
        sb.append("declare void @turtle_avanza(i32)\n");
        sb.append("declare void @turtle_giraDerecha(i32)\n");
        sb.append("declare void @turtle_giraIzquierda(i32)\n");
        sb.append("declare void @turtle_centro()\n");
        sb.append("declare void @turtle_ponX(i32)\n");
        sb.append("declare void @turtle_ponY(i32)\n");
        sb.append("declare void @turtle_ponPos(i32,i32)\n");
        sb.append("declare void @turtle_bajaLapiz()\n");
        sb.append("declare void @turtle_subeLapiz()\n");
        sb.append("declare void @turtle_ponColorLapiz(i32)\n");
        sb.append("declare void @turtle_espera(i32)\n");
        sb.append("declare i32 @runtime_azar(i32)\n\n");
    }

    private void emitGlobals() {
        for (String g : mod.globals) {
            sb.append("@").append(g).append(" = global i32 0\n");
        }
        if (!mod.globals.isEmpty()) sb.append("\n");
    }

    // ==== utilities for strings ====
    private String internString(String s) {
        String key = s;
        String existing = strGlobals.get(key);
        if (existing != null) return existing;
        String name = "@.str" + (strCounter++);
        // escape to LLVM c"..." with null terminator
        String escaped = s.replace("\\", "\\5C").replace("\"","\\22");
        int n = s.length() + 1;
        sb.insert(0, "@" + name.substring(2) + " = private constant ["+n+" x i8] c\"" + escaped + "\\00\"\n");
        // NOTE: inserted at top for readability (you could append instead)
        strGlobals.put(key, name);
        return name;
    }

    private String cstrPtr(String global) {
        // getelementptr para i8*
        // %p = getelementptr inbounds ([N x i8], [N x i8]* @.str, i32 0, i32 0)
        // Lo generaremos inline donde se use.
        return global;
    }

    // ==== function emission ====
    private void emitFunction(IRFunction f) {
        // firma: todo void; params i32
        String params = f.params.stream()
                .map(p -> "i32 %"+p)
                .collect(Collectors.joining(", "));
        sb.append("define void @").append(f.name).append("(").append(params).append(") {\n");

        // entry: allocas
        sb.append("entry:\n");

        // locals: allocas
        Set<String> locals = new LinkedHashSet<>(f.locals);
        locals.addAll(f.params); // reservamos espacio para params como variables
        for (String v : locals) {
            sb.append("  %").append(v).append(".alloca = alloca i32\n");
        }
        // store de params
        for (String p : f.params) {
            sb.append("  store i32 %").append(p).append(", i32* %").append(p).append(".alloca\n");
        }

        boolean needCont = false;
        int contCount = 0;

        // labels: usaremos nombres directos
        for (IRInstr ins : f.code) {
            if (needCont && !(ins instanceof IRLabelInstr)) {
                String c = "_cont" + (++contCount);
                sb.append("  br label %").append(c).append("\n");
                sb.append(c).append(":\n");
                needCont = false;
            }

            if (ins instanceof IRLabelInstr) {
                IRLabelInstr L = (IRLabelInstr) ins;
                sb.append(L.label.name).append(":\n");
                continue;
            }
            if (ins instanceof IRGoto) {
                IRGoto g = (IRGoto) ins;
                sb.append("  br label %").append(g.target.name).append("\n");
                needCont = true;
                continue;
            }
            if (ins instanceof IRIfGoto) {
                IRIfGoto ig = (IRIfGoto) ins;
                // si cond no es i1, comparamos != 0
                String c = asValue(ig.cond, VType.BOOL);
                sb.append("  br i1 ").append(c).append(", label %")
                  .append(ig.target.name).append(", label %");
                String cfall = "_cont" + (++contCount);
                sb.append(cfall).append("\n");
                sb.append(cfall).append(":\n");
                continue;
            }
            if (ins instanceof IRReturn) {
                sb.append("  ret void\n");
                continue;
            }
            if (ins instanceof IRPrintln) {
                IRPrintln p = (IRPrintln) ins;
                // cadenas literales → println_cstr
                if (p.value instanceof IRConst && ((IRConst)p.value).value instanceof String) {
                    String txt = (String)((IRConst)p.value).value;
                    String gname = internString(txt);
                    int n = txt.length()+1;
                    String gv = "@"+gname.substring(2); // por cómo lo insertamos
                    String tmp = fresh();
                    sb.append("  ").append(tmp).append(" = getelementptr inbounds ([").append(n).append(" x i8], [")
                            .append(n).append(" x i8]* ").append(gv).append(", i32 0, i32 0)\n");
                    sb.append("  call void @println_cstr(i8* ").append(tmp).append(")\n");
                } else {
                    // si sabemos que es bool → println_bool; si no, i32
                    VType vt = guessType(p.value);
                    String v = asValue(p.value, vt);
                    if (vt == VType.BOOL) {
                        sb.append("  call void @println_bool(i1 ").append(v).append(")\n");
                    } else {
                        if (vt == VType.BOOL) {
                            // (ya está cubierto)
                        }
                        // si era bool y lo pedimos como i32 hacemos zext en asValue
                        sb.append("  call void @println_i32(i32 ").append(v).append(")\n");
                    }
                }
                continue;
            }
            if (ins instanceof IRMove) {
                IRMove m = (IRMove) ins;
                if (m.dst instanceof IRVar) {
                    String ptr = ptrOf((IRVar)m.dst);
                    String v = asValue(m.src, VType.INT);
                    sb.append("  store i32 ").append(v).append(", i32* ").append(ptr).append("\n");
                } else if (m.dst instanceof IRTemp) {
                    String dst = "%"+((IRTemp)m.dst).name;
                    VType vt = guessType(m.src);
                    String v = asValue(m.src, vt);
                    // guarda el valor en un %temp SSA (normalizando a i32 si hace falta)
                    if (vt == VType.BOOL) {
                        // guardaremos como i1 pero recordamos tipo
                        tempType.put(((IRTemp)m.dst).name, VType.BOOL);
                        sb.append("  ").append(dst).append(" = ").append(v.startsWith("%")||v.equals("true")||v.equals("false")?"":"").append(v).append("\n");
                        // Nota: asValue(BOOL) devuelve algo como %tN (i1), así que sólo asignamos alias:
                        // pero LLVM no permite "x = %y". Mejora: si es temp->temp, mejor mapea: %dst = add i1 0, %src? Simplifiquemos:
                        // Haré un zext a i1->i1 redundante para cumplir sintaxis:
                        sb.append("  ").append(dst).append(" = or i1 ").append(v).append(", false\n");
                    } else {
                        tempType.put(((IRTemp)m.dst).name, VType.INT);
                        if (v.equals("true") || v.equals("false")) {
                            // boolean literal → zext a i32
                            String b = fresh();
                            sb.append("  ").append(b).append(" = zext i1 ").append(v).append(" to i32\n");
                            sb.append("  ").append(dst).append(" = add i32 ").append(b).append(", 0\n");
                        } else {
                            sb.append("  ").append(dst).append(" = add i32 ").append(v).append(", 0\n");
                        }
                    }
                }
                continue;
            }
            if (ins instanceof IRBinOpInstr) {
                IRBinOpInstr b = (IRBinOpInstr) ins;
                String dst = "%"+((IRTemp)b.dst).name;
                switch (b.op) {
                    case ADD: emitArith(dst, "add", b.a, b.b); break;
                    case MUL: emitArith(dst, "mul", b.a, b.b); break;
                    case DIV: emitArith(dst, "sdiv", b.a, b.b); break;
                    case SUB: emitArith(dst, "sub", b.a, b.b); break;
                    case EQ:  emitCmp(dst, "eq", b.a, b.b);  break;
                    case LT:  emitCmp(dst, "slt", b.a, b.b); break;
                    case GT:  emitCmp(dst, "sgt", b.a, b.b); break;
                    case AND: emitBoolBin(dst, "and", b.a, b.b); break;
                    case OR:  emitBoolBin(dst, "or",  b.a, b.b); break;
                    case POW: emitPow(dst, b.a, b.b); break;
                    case DIFF: emitArith(dst, "sub", b.a, b.b); break;
                    case SUM:  emitArith(dst, "add", b.a, b.b); break;
                    case PROD: emitArith(dst, "mul", b.a, b.b); break;
                    default:
                        sb.append("  ; unsupported binop ").append(b.op).append("\n");
                }
                continue;
            }
            if (ins instanceof IRUnaryOpInstr) {
                IRUnaryOpInstr u = (IRUnaryOpInstr) ins;
                String dst = "%"+((IRTemp)u.dst).name;
                switch (u.op) {
                    case NOT: {
                        String v = asValue(u.v, VType.BOOL);
                        tempType.put(((IRTemp)u.dst).name, VType.BOOL);
                        sb.append("  ").append(dst).append(" = xor i1 ").append(v).append(", true\n");
                        break;
                    }
                    case NEG: {
                        String v = asValue(u.v, VType.INT);
                        tempType.put(((IRTemp)u.dst).name, VType.INT);
                        sb.append("  ").append(dst).append(" = sub i32 0, ").append(v).append("\n");
                        break;
                    }
                    default:
                        sb.append("  ; unsupported unary ").append(u.op).append("\n");
                }
                continue;
            }
            if (ins instanceof IRCall) {
                IRCall c = (IRCall) ins;
                String callee = mapCallee(c.callee);
                // args: todos i32 (salvo que sean strings constantes → i8*)
                List<String> args = new ArrayList<>();
                List<String> argTys = new ArrayList<>();
                for (IRValue av : c.args) {
                    if (av instanceof IRConst && ((IRConst)av).value instanceof String) {
                        String txt = (String)((IRConst)av).value;
                        String gname = internString(txt);
                        int n = txt.length()+1;
                        String tmp = fresh();
                        sb.append("  ").append(tmp).append(" = getelementptr inbounds ([").append(n).append(" x i8], [")
                          .append(n).append(" x i8]* @").append(gname.substring(2)).append(", i32 0, i32 0)\n");
                        args.add(tmp);
                        argTys.add("i8*");
                    } else {
                        String v = asValue(av, VType.INT);
                        args.add(v);
                        argTys.add("i32");
                    }
                }
                if (c.dst == null) {
                    sb.append("  call ").append(retTy(c.callee)).append(" @").append(callee)
                      .append("(").append(joinSig(argTys, args)).append(")\n");
                } else {
                    String dst = "%"+((IRTemp)c.dst).name;
                    if (c.callee.startsWith("runtime.azar")) {
                        tempType.put(((IRTemp)c.dst).name, VType.INT);
                        sb.append("  ").append(dst).append(" = call i32 @runtime_azar(")
                          .append(joinSig(argTys, args)).append(")\n");
                    } else {
                        // por defecto sin retorno
                        sb.append("  call ").append(retTy(c.callee)).append(" @").append(callee)
                          .append("(").append(joinSig(argTys, args)).append(")\n");
                        // si esperaban valor, ponemos 0
                        tempType.put(((IRTemp)c.dst).name, VType.INT);
                        sb.append("  ").append(dst).append(" = add i32 0, 0\n");
                    }
                }
                continue;
            }

            // fallback
            sb.append("  ; unhandled: ").append(ins.getClass().getSimpleName()).append("\n");
        }

        sb.append("}\n\n");
    }

    private String retTy(String callee) {
        if (callee.startsWith("runtime.azar")) return "i32";
        if (callee.startsWith("turtle.")) return "void";
        return "void"; // user procs sin retorno
    }

    private String mapCallee(String c) {
        if (c.startsWith("turtle.")) {
            return c.replace('.', '_');
        }
        if (c.startsWith("runtime.")) {
            return c.replace('.', '_');
        }
        return c; // user function
    }

    private String joinSig(List<String> tys, List<String> vs) {
        List<String> parts = new ArrayList<>();
        for (int i=0;i<tys.size();i++) parts.add(tys.get(i) + " " + vs.get(i));
        return String.join(", ", parts);
    }

    private void emitArith(String dst, String op, IRValue a, IRValue b) {
        String va = asValue(a, VType.INT);
        String vb = asValue(b, VType.INT);
        tempType.put(dst.substring(1), VType.INT);
        sb.append("  ").append(dst).append(" = ").append(op).append(" i32 ").append(va).append(", ").append(vb).append("\n");
    }

    private void emitCmp(String dst, String pred, IRValue a, IRValue b) {
        String va = asValue(a, VType.INT);
        String vb = asValue(b, VType.INT);
        tempType.put(dst.substring(1), VType.BOOL);
        sb.append("  ").append(dst).append(" = icmp ").append(pred).append(" i32 ").append(va).append(", ").append(vb).append("\n");
    }

    private void emitBoolBin(String dst, String op, IRValue a, IRValue b) {
        String va = asValue(a, VType.BOOL);
        String vb = asValue(b, VType.BOOL);
        tempType.put(dst.substring(1), VType.BOOL);
        sb.append("  ").append(dst).append(" = ").append(op).append(" i1 ").append(va).append(", ").append(vb).append("\n");
    }

    private void emitPow(String dst, IRValue a, IRValue b) {
        // pow entero simple: a^b con bucle (i32)
        String base = asValue(a, VType.INT);
        String exp  = asValue(b, VType.INT);
        tempType.put(dst.substring(1), VType.INT);

        String res = fresh(), i = fresh(), Lc = freshLabel("pow_c"), Lb = freshLabel("pow_b"), Le = freshLabel("pow_e"), cmp = fresh();
        sb.append("  ").append(res).append(" = add i32 1, 0\n");
        sb.append("  ").append(i).append(" = add i32 0, 0\n");
        sb.append(Lc.substring(1)).append(":\n");
        sb.append("  ").append(cmp).append(" = icmp slt i32 ").append(i).append(", ").append(exp).append("\n");
        sb.append("  br i1 ").append(cmp).append(", label ").append(Lb).append(", label ").append(Le).append("\n");
        sb.append(Lb.substring(1)).append(":\n");
        String tmp = fresh();
        sb.append("  ").append(tmp).append(" = mul i32 ").append(res).append(", ").append(base).append("\n");
        sb.append("  ").append(res).append(" = add i32 ").append(tmp).append(", 0\n");
        String i2 = fresh();
        sb.append("  ").append(i2).append(" = add i32 ").append(i).append(", 1\n");
        sb.append("  ").append(i).append(" = add i32 ").append(i2).append(", 0\n");
        sb.append("  br label ").append(Lc).append("\n");
        sb.append(Le.substring(1)).append(":\n");
        sb.append("  ").append(dst).append(" = add i32 ").append(res).append(", 0\n");
    }

    private String ptrOf(IRVar v) {
        String name = v.name;
        if (isGlobal(name)) return "@"+name;
        return "%"+name+".alloca";
    }

    private boolean isGlobal(String name) { return mod.globals.contains(name); }

    private VType guessType(IRValue v) {
        if (v instanceof IRConst) {
            Object o = ((IRConst)v).value;
            if (o instanceof String) return VType.STR;
            if (o instanceof Boolean) return VType.BOOL;
            return VType.INT;
        }
        if (v instanceof IRTemp) {
            VType t = tempType.get(((IRTemp)v).name);
            return (t == null) ? VType.INT : t;
        }
        // VarRef (IRVar) -> int (el runtime maneja ints/bools como i32; los bools se forman con icmp/and/or)
        return VType.INT;
    }

    private String asValue(IRValue v, VType want) {
        if (v instanceof IRConst) {
            Object o = ((IRConst)v).value;
            if (o instanceof String) {
                String gname = internString((String)o);
                int n = ((String)o).length()+1;
                String tmp = fresh();
                sb.append("  ").append(tmp).append(" = getelementptr inbounds ([")
                  .append(n).append(" x i8], [").append(n).append(" x i8]* @")
                  .append(gname.substring(2)).append(", i32 0, i32 0)\n");
                return tmp; // i8*
            }
            if (o instanceof Boolean) return ((Boolean)o) ? "true" : "false";
            return String.valueOf(((Number)o).intValue());
        }
        if (v instanceof IRTemp) {
            String n = "%"+((IRTemp)v).name;
            VType have = guessType(v);
            if (want == VType.INT && have == VType.BOOL) {
                String z = fresh();
                sb.append("  ").append(z).append(" = zext i1 ").append(n).append(" to i32\n");
                return z;
            }
            if (want == VType.BOOL && have == VType.INT) {
                String cmp = fresh();
                sb.append("  ").append(cmp).append(" = icmp ne i32 ").append(n).append(", 0\n");
                tempType.put(((IRTemp)v).name, VType.BOOL);
                return cmp;
            }
            return n;
        }
        if (v instanceof IRVar) {
            String p = ptrOf((IRVar)v);
            String tmp = fresh();
            sb.append("  ").append(tmp).append(" = load i32, i32* ").append(p).append("\n");
            if (want == VType.BOOL) {
                String cmp = fresh();
                sb.append("  ").append(cmp).append(" = icmp ne i32 ").append(tmp).append(", 0\n");
                return cmp;
            }
            return tmp;
        }
        return "0";
    }

    private int id = 0, lid = 0;
    private String fresh() { return "%_t" + (++id); }
    private String freshLabel(String b){ return "%"+b+"_"+(++lid); }
}
